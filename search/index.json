[{"content":"迪杰斯特拉算法原理及Python实现 算法简介 A*算法是一种用于求解最短路径问题的启发式搜索算法，广泛应用于机器人路径规划、游戏地图寻路等场景。与 Dijkstra 算法不同，A* 算法结合了实际路径代价和启发式估计，从而能更高效地找到从起点到终点的最优路径。\n算法原理 A*算法基于以下评价函数进行节点选择：\n1 f(n) = g(n) + h(n) g(n)：从起点到当前节点 n 的实际路径代价 h(n)：从当前节点 n 到目标节点的启发式估计（通常使用曼哈顿距离） f(n)：总代价函数，表示当前路径的优劣程度 通过优先扩展 f(n) 最小的节点，A*算法在保证最优性的同时提高了搜索效率。\n曼哈顿距离 A*算法中常用的启发函数之一是曼哈顿距离（Manhattan Distance），适用于只能沿网格上下左右移动的情况。\n它的计算方式为：\n1 2 复制编辑 h(n) = |x₁ - x₂| + |y₁ - y₂| 其中 (x₁, y₁) 是当前节点的坐标，(x₂, y₂) 是目标节点的坐标。\n这种距离计算方式类似在城市街区中沿街道走路，不能穿墙或斜着走，故称为“曼哈顿”——得名于纽约曼哈顿的棋盘格街道布局。\n算法流程 步骤1：初始化 初始化三个核心数组：\ng数组：记录从起点到当前节点的最小代价，初始全部为 ∞，起点为 0 h数组：记录当前节点到目标节点的启发式估值 f数组：记录总代价，f = g + h open_list：优先队列（小顶堆），用于选择当前代价最小的节点 closed_list：已访问节点集合，避免重复扩展 parent字典：记录每个节点的前驱节点 步骤2：选择f值最小的节点 从 open_list 中取出 f(n) 最小的节点，作为当前处理节点。\n步骤3：判断是否到达目标节点 若当前节点为目标节点，则说明路径已找到，调用 seek_path 方法回溯路径。\n步骤4：扩展邻居节点 获取四个方向的可通行邻居节点（上下左右） 对每个邻居，计算新的 g、h、f 值 若该路径更优，则更新邻居节点的代价信息并加入 open_list Python实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import heapq import matplotlib.pyplot as plt import numpy as np class AStar: def __init__(self, grid, start, goal): self.grid = grid self.start = start self.goal = goal self.rows = len(grid) self.cols = len(grid[0]) self.open_list = [] self.closed_list = set() self.f = np.full((self.rows, self.cols), np.inf) self.g = np.full((self.rows, self.cols), np.inf) self.h = np.full((self.rows, self.cols), 0) self.parent = {} def seek_heuristic(self, x, y): return abs(self.goal[0] - x) + abs(self.goal[1] - y) def seek_neighborhood(self, x, y): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] neighbors = [] for dx, dy in directions: if 0 \u0026lt;= x + dx \u0026lt; self.rows and 0 \u0026lt;= y + dy \u0026lt; self.cols and self.grid[x + dx][y + dy] == 0: neighbors.append((x + dx, y + dy)) return neighbors def run(self): self.g[self.start[0], self.start[1]] = 0 self.h[self.start[0], self.start[1]] = self.seek_heuristic(*self.start) self.f[self.start[0], self.start[1]] = self.g[self.start[0], self.start[1]] + self.h[self.start[0], self.start[1]] heapq.heappush(self.open_list, (self.f[self.start[0], self.start[1]], self.start)) while self.open_list: _, current_node = heapq.heappop(self.open_list) if current_node == self.goal: return self.seek_path() self.closed_list.add(current_node) for neighbor in self.seek_neighborhood(*current_node): if neighbor in self.closed_list: continue current_g = self.g[current_node[0], current_node[1]] + 1 if neighbor not in self.parent or current_g \u0026lt; self.g[neighbor[0], neighbor[1]]: self.parent[neighbor] = current_node self.g[neighbor[0], neighbor[1]] = current_g self.h[neighbor[0], neighbor[1]] = self.seek_heuristic(*neighbor) self.f[neighbor[0], neighbor[1]] = self.g[neighbor[0], neighbor[1]] + self.h[neighbor[0], neighbor[1]] if neighbor not in [node[1] for node in self.open_list]: heapq.heappush(self.open_list, (self.f[neighbor[0], neighbor[1]], neighbor)) return None def seek_path(self): path = [] current_node = self.goal while current_node != self.start: path.append(current_node) current_node = self.parent[current_node] path.append(self.start) path.reverse() return path 可视化路径 1 2 3 4 5 6 7 8 9 10 def plot_path(grid, path): plt.figure(figsize=(8, 8)) plt.imshow(grid, cmap=\u0026#39;Greys\u0026#39;, origin=\u0026#39;lower\u0026#39;) path_x, path_y = zip(*path) plt.plot(path_y, path_x, color=\u0026#39;r\u0026#39;, linewidth=2, marker=\u0026#39;o\u0026#39;) plt.scatter(path_y[0], path_x[0], color=\u0026#39;g\u0026#39;, s=100, label=\u0026#39;Start\u0026#39;) plt.scatter(path_y[-1], path_x[-1], color=\u0026#39;b\u0026#39;, s=100, label=\u0026#39;Goal\u0026#39;) plt.legend() plt.title(\u0026#34;A* Pathfinding\u0026#34;) plt.show() 代码测试 主程序测试代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if __name__ == \u0026#34;__main__\u0026#34;: grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) astar = AStar(grid, start, goal) path = astar.run() if path: print(\u0026#34;路径为：\u0026#34;, path) plot_path(grid, path) else: print(\u0026#34;未找到路径\u0026#34;) 运行结果为：\n1 路径为： [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (2, 3), (2, 2), (2, 1), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)] 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import heapq import matplotlib.pyplot as plt import numpy as np class AStar: def __init__(self, grid, start, goal): self.grid=grid self.start=start self.goal=goal self.rows=len(grid) self.cols=len(grid[0]) self.open_list=[] self.closed_list=set() self.f=np.full((self.rows,self.cols),np.inf) self.g=np.full((self.rows,self.cols),np.inf) self.h=np.full((self.rows,self.cols),0) self.parent={} def seek_heuristic(self,x,y): return abs(self.goal[0]-x)+abs(self.goal[1]-y) def seek_neighborhood(self,x,y): directions=[(0,1),(0,-1),(1,0),(-1,0)] neighbors=[] for dx,dy in directions: if 0\u0026lt;=x+dx\u0026lt;self.rows and 0\u0026lt;=y+dy\u0026lt;self.cols and self.grid[x+dx][y+dy]==0: neighbors.append((x+dx,y+dy)) return neighbors def run(self): # 初始化起点 self.g[self.start[0], self.start[1]] = 0 self.h[self.start[0], self.start[1]] = self.seek_heuristic(self.start[0], self.start[1]) self.f[self.start[0], self.start[1]] = self.g[self.start[0], self.start[1]]+self.h[self.start[0], self.start[1]] heapq.heappush(self.open_list,(self.f[self.start[0], self.start[1]],self.start)) while self.open_list: _,current_node=heapq.heappop(self.open_list) if current_node==self.goal: return self.seek_path() self.closed_list.add(current_node) for neighbor in self.seek_neighborhood(current_node[0],current_node[1]): if neighbor in self.closed_list: continue current_g=self.g[current_node[0],current_node[1]] + 1 if neighbor not in self.parent or current_g\u0026lt;self.g[neighbor[0],neighbor[1]]: self.parent[neighbor]=current_node self.g[neighbor[0],neighbor[1]] = current_g self.h[neighbor[0],neighbor[1]] = self.seek_heuristic(neighbor[0],neighbor[1]) self.f[neighbor[0],neighbor[1]] = self.g[neighbor[0],neighbor[1]] + self.h[neighbor[0],neighbor[1]] if neighbor not in [node[1] for node in self.open_list]: heapq.heappush(self.open_list,(self.f[neighbor[0],neighbor[1]],neighbor)) return None def seek_path(self): path=[] current_node=self.goal while current_node!=self.start: path.append(current_node) current_node=self.parent[current_node] path.append(self.start) path.reverse() return path def plot_path(grid,path): plt.figure(figsize=(8, 8)) plt.imshow(grid, cmap=\u0026#39;Greys\u0026#39;, origin=\u0026#39;lower\u0026#39;) path_x, path_y = zip(*path) plt.plot(path_y, path_x, color=\u0026#39;r\u0026#39;, linewidth=2, marker=\u0026#39;o\u0026#39;) plt.scatter(path_y[0], path_x[0], color=\u0026#39;g\u0026#39;, s=100, label=\u0026#39;Start\u0026#39;) plt.scatter(path_y[-1], path_x[-1], color=\u0026#39;b\u0026#39;, s=100, label=\u0026#39;Goal\u0026#39;) plt.legend() plt.title(\u0026#34;A* Pathfinding\u0026#34;) plt.show() # 测试 if __name__ == \u0026#34;__main__\u0026#34;: grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) astar = AStar(grid, start, goal) path = astar.run() if path: print(\u0026#34;Path found:\u0026#34;, path) plot_path(grid, path) else: print(\u0026#34;No path found\u0026#34;) ","date":"2025-04-27T14:44:25+08:00","image":"https://example.com/p/a%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_d5168aa05a06ff51.jpg","permalink":"https://example.com/p/a%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"A*算法原理及Python实现"},{"content":"迪杰斯特拉算法原理及Python实现 算法简介 迪杰斯特拉（Dijkstra）算法主要用于求解没有负值的有向图的单源最短路径问题。\n算法原理 算法基于贪心策略，其核心思想是通过逐步扩展已知最短路径的集合来找到从起点到所有其他节点的最短路径。\n算法流程 步骤1：初始化 初始化cost数组，path数组和visited数组\ncost数组 对于cost数组，初始全部设置为最大值，起点节点设置为0\n1 cost数组：cost[i]表示从start_index到i号元素的最小花费 path数组 对于path数组，初始全部设置为-1，表示不可达，起点节点设置为起点节点的位置\n1 path数组：path[i]表示从start_index到i号元素的最短路径中，到达i号元素的前一个元素索引为path[i]（即想要以最小花费到达i号元素，需要通过path[i]号元素） visited数组 对于visited数组，初始全部设置为0，起点节点设置为1\n1 visited数组：visited[i]表示i号元素是否被访问过（visited[i]==1表示已经找到了最优路径） 步骤2：找到下一个“最优节点” “最优节点”指的是从当前节点到其他节点中代价最小的节点，这个“最优节点”也会作为下一次迭代的“当前节点”\n步骤3：更新visited数组 将找到的最优节点设置成“已访问”状态，即将其设置为“当前节点”\n步骤4：更新“最优节点附近节点的数据” 访问所有还未被访问的节点，若从当前节点“到此节点的代价更小，则更新cost数组和path数组\nPython实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def dijkstra(graph,start_index,max): # 初始化cost,path,visited数组 # cost数组：cost[i]表示从start_index到i号元素的最小花费 cost=[max]*len(graph) cost[start_index] = 0 # path数组：path[i]表示从start_index到i号元素的最短路径中，到达i号元素的前一个元素索引为path[i]（即想要以最小花费到达i号元素，需要通过path[i]号元素） path = [-1] * len(graph) path[start_index] = start_index # visited数组：visited[i]表示i号元素是否被访问过（已经找到了最优路径） visited=[0]*len(graph) visited[start_index]=1 for i in range(len(graph)): if(visited[i]==0): cost[i]=graph[start_index][i] # path[i]=-1表示不可达 path[i]=(start_index if(cost[i]\u0026lt;max) else -1) # 主体代码 for i in range(1,len(graph)): cur_index=-1 min_cost=max # 找到下一步代价最小的节点 for j in range(len(graph)): if(visited[j]==0): if(cost[j]\u0026lt;min_cost): min_cost=cost[j] cur_index=j # 如果没有找到可访问的节点，退出循环 if cur_index==-1: break # 标记下一步代价最小的节点为已访问的节点（当前节点） visited[cur_index]=1 # 依据找到的下一步代价最小的节点cur_index更新其附近一圈的节点数据 for k in range(len(graph)): if(visited[k]==0): if(cost[cur_index]+graph[cur_index][k]\u0026lt;cost[k]): cost[k]=cost[cur_index]+graph[cur_index][k] path[k]=cur_index return path 输入与输出 输入为图的邻接矩阵，其中 graph[i][j] 表示从节点 i 到节点 j 的边的权重。如果节点之间没有直接的边，则用一个足够大的值（如 max）表示不可达。\n输出为 path 数组，其中 path[i] 表示从起点到节点 i 的最短路径中，到达节点 i 的前一个节点的索引。如果节点不可达，则 path[i] 为 -1\n若想通过path数组得到从起点到某个节点k的路径，可由如下代码实现：\n1 2 3 4 5 6 7 8 9 10 def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;没有路径可达\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list 代码测试 主程序测试代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if __name__==\u0026#34;__main__\u0026#34;: max=2**31-1 graph=[ [max, max, 10, max, 30, 100], [max, max, 5, max, max, max], [max, max, max, 50, max, max], [max, max, max, max, max, 10], [max, max, max, 20, max, 60], [max, max, max, max, max, max], ] result=dijkstra(graph,0,max) print(\u0026#34;最短路径的前驱节点数组为：\u0026#34;,result) target_index = 5 path_to_target = get_path(result, 0, target_index) print(f\u0026#34;从起点到目标节点 {target_index} 的路径为：\u0026#34;, path_to_target) 运行结果为：\n1 2 3 E:\\BLOG_article\\Dijkstra\\.venv\\Scripts\\python.exe E:\\BLOG_article\\Dijkstra\\Dijkstra.py 最短路径的前驱节点数组为： [0, -1, 0, 4, 0, 3] 从起点到目标节点 5 的路径为： [0, 4, 3, 5] 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def dijkstra(graph,start_index,max): # 初始化cost,path,visited数组 # cost数组：cost[i]表示从start_index到i号元素的最小花费 cost=[max]*len(graph) cost[start_index] = 0 # path数组：path[i]表示从start_index到i号元素的最短路径中，到达i号元素的前一个元素索引为path[i]（即想要以最小花费到达i号元素，需要通过path[i]号元素） path = [-1] * len(graph) path[start_index] = start_index # visited数组：visited[i]表示i号元素是否被访问过（已经找到了最优路径） visited=[0]*len(graph) visited[start_index]=1 for i in range(len(graph)): if(visited[i]==0): cost[i]=graph[start_index][i] # path[i]=-1表示不可达 path[i]=(start_index if(cost[i]\u0026lt;max) else -1) # 主体代码 for i in range(1,len(graph)): cur_index=-1 min_cost=max # 找到下一步代价最小的节点 for j in range(len(graph)): if(visited[j]==0): if(cost[j]\u0026lt;min_cost): min_cost=cost[j] cur_index=j # 如果没有找到可访问的节点，退出循环 if cur_index==-1: break # 标记下一步代价最小的节点为已访问的节点 visited[cur_index]=1 # 依据找到的下一步代价最小的节点cur_index更新其附近一圈的节点数据 for k in range(len(graph)): if(visited[k]==0): if(cost[cur_index]+graph[cur_index][k]\u0026lt;cost[k]): cost[k]=cost[cur_index]+graph[cur_index][k] path[k]=cur_index return path def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;No path exists\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list if __name__==\u0026#34;__main__\u0026#34;: max=2**31-1 graph=[ [max, max, 10, max, 30, 100], [max, max, 5, max, max, max], [max, max, max, 50, max, max], [max, max, max, max, max, 10], [max, max, max, 20, max, 60], [max, max, max, max, max, max], ] result=dijkstra(graph,0,max) print(\u0026#34;最短路径的前驱节点数组为：\u0026#34;,result) target_index = 5 path_to_target = get_path(result, 0, target_index) print(f\u0026#34;从起点到目标节点 {target_index} 的路径为：\u0026#34;, path_to_target) ","date":"2025-04-13T14:44:25+08:00","image":"https://example.com/p/dijkstra%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_edd18e5053fe4098.png","permalink":"https://example.com/p/dijkstra%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"Dijkstra原理及Python实现"},{"content":"标题 标题2 ","date":"2025-04-13T14:44:25+08:00","image":"https://example.com/p/first_test/test_hu_22ab779589b0bb50.png","permalink":"https://example.com/p/first_test/","title":"First_test"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"}]