[{"content":"创建一个深度学习虚拟环境（包含d2l包） Step1 创建一个名为“d2l_env”的虚拟环境并激活（推荐 Python 3.9，兼容性最佳）：\n1 conda create -n d2l_env python=3.9 1 conda activate d2l_env Step2 使用pip安装pytorch（最新版的pytorch已经不支持conda安装，故采用pip）：\n1 pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121 Step3 使用conda安装常见相关依赖\n1 conda install matplotlib pandas jupyter ipykernel Step4 使用pip安装指定版本的d2l包：\n1 pip install d2l==1.0.2 Step5 将这个虚拟环境加入jupyter notebook内核：\n1 python -m ipykernel install --user --name d2l_env --display-name \u0026#34;Python (d2l_env)\u0026#34; ","date":"2025-08-05T14:44:25+08:00","image":"https://example.com/p/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%8C%85%E5%90%ABd2l%E5%8C%85/index_hu_8485bb27c6ba89e1.jpg","permalink":"https://example.com/p/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%8C%85%E5%90%ABd2l%E5%8C%85/","title":"创建一个深度学习虚拟环境（包含d2l包）"},{"content":"线性回归解析解的推导 问题形式化 我们要做的是： 首先给定一组数据 $$ (X,y)\\quad其中X∈R^{n×d}，y∈R^n $$要拟合一个线性模型 $$ y=Xw+b $$ 找到使预测和真实值之间均方误差最小的w和b。\n其次，把每个样本的特征后面加上一列全是1的列，这样就可以把b作为w的一部分处理了。\n所以，如果原始 X 是 n×d 矩阵，我们构造 $$ {X} = [X \\quad \\mathbf{1}] $$其中 1是 n×1 的全1列向量。 此时参数 $$ ~\\tilde{w} 为(d+1) \\times 1向量，最后一个元素就是b $$ 写出目标函数 线性回归的目标是最小化残差平方和（MSE）： $$ L(\\tilde{w}) = \\| y - \\tilde{X}\\tilde{w} \\|^2 $$ 将其写成矩阵相乘的形式： $$ L(w)=∥y−Xw∥^2=(y−Xw) ^⊤(y−Xw) $$ 展开目标函数为： $$ L(w)=y^⊤y−2y^⊤Xw+w^⊤X^⊤Xw $$ 其中： $$ 𝑦^⊤𝑦y^⊤y 是常数项 $$$$ −2𝑦^⊤𝑋𝑤−2y^⊤Xw 是一次项 $$$$ w^⊤X^⊤Xw 是二次项 $$ 解出解析解 现在来对每一项分别求导： $$ y^\\top y：跟w无关，导数是0 $$$$ -2y^\\top Xw：对w求导，就是-2X^\\top y $$$$ w^\\top X^\\top Xw ：对w求导，就是 2X^\\top X w $$ 这样，整个损失函数对w的导数是： $$ \\frac{\\partial L}{\\partial w} = 0 - 2X^\\top y + 2X^\\top X w\\\\= 2X^\\top X w - 2X^\\top y $$ 零其为0，得 $$ X^⊤Xw=X^⊤y $$ 两边左乘 $$ (𝑋^⊤𝑋)^{−1} $$ 得到 $$ w=(X^⊤X)^{−1}X^⊤y $$ 附 矩阵相乘展开： $$ (a−b)^⊤(a−b)=a^⊤a−a^⊤b−b^⊤a+b^⊤b\\\\因为𝑎^⊤𝑏和𝑏^⊤𝑎是标量（它们互为转置，结果相同），所以上面中间两项可以合并为：\\\\𝑎⊤𝑎−2𝑎⊤𝑏+𝑏⊤𝑏 $$ 矩阵求导基础： $$ \\frac{\\partial}{\\partial w}(w^\\top A w) = 2Aw\\quad（其中 A 是对称矩阵） $$$$ \\frac{\\partial}{\\partial w}(b^\\top w) = b\\quad（b 是和 w 维度相同的向量） $$","date":"2025-08-04T14:44:25+08:00","image":"https://example.com/p/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E8%A7%A3%E6%9E%90%E8%A7%A3%E7%9A%84%E6%8E%A8%E5%AF%BC/index_hu_17c525d58159b80.png","permalink":"https://example.com/p/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E8%A7%A3%E6%9E%90%E8%A7%A3%E7%9A%84%E6%8E%A8%E5%AF%BC/","title":"线性回归解析解的推导"},{"content":"Bellman-Ford算法原理及Python实现 算法简介 Bellman-Ford算法主要用于求解有向图的单源最短路径问题，与迪杰斯特拉算法不同，他可以处理带有负权值的图，并且可以检测图中是否有负权环（负权环指的是从源点到源点的一个环，并且环上权重和为负数）。\n算法原理 ​\t它的基本思想是松弛（Relaxation）操作。松弛是指对于每一条边（u，v），如果从源点到顶点 u 的最短路径距离已知，并且从源点到顶点 v 的距离可以通过经过顶点 u 的路径来更新为一个更小的值，那么就更新顶点 v 的当前最短路径距离。\n​\t算法重复进行松弛操作，对于图中的每一条边都进行检查，尝试更新顶点的最短路径估计值。这个过程需要进行 |V| - 1 次（|V| 是图中顶点的数量），因为在最坏情况下，一个顶点的最短路径可能需要经过所有其他顶点。\n​\t因此算法的时间复杂度为 O（|V|・|E|），其中 |V| 是顶点数，|E| 是边数。\n算法流程 步骤1：初始化 将源点的最短路径距离设为 0，其他所有顶点的最短路径距离设为无穷大。\n步骤2：反复进行松弛操作 对于每一条边（u，v），在 |V| - 1 次迭代中，如果当前顶点 u 的最短路径距离加上边（u，v）的权重小于顶点 v 当前记录的最短路径距离，则更新顶点 v 的最短路径距离。\n步骤3：检测是否存在负权回路 在完成 |V| - 1 次松弛操作后，再对所有边进行一次检查。如果还能松弛，说明图中存在从源点可达的负权回路，此时最短路径不存在（因为可以无限绕负权回路来降低路径权重）。\nPython实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Edge: def __init__(self, src, dest, weight): self.src = src self.dest = dest self.weight = weight def bellman_ford(vertices, edges, src): # 初始化距离数组，距离源点的距离为无穷大 dist = [float(\u0026#39;inf\u0026#39;)] * (vertices + 1) dist[src] = 0 # 源点到自身的距离为 0 # 进行 vertices-1 次松弛操作 for _ in range(vertices - 1): updated = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: dist[v] = dist[u] + weight updated = True if not updated: break # 如果没有边可以松弛，提前退出 # 检测是否存在负权回路 has_negative_cycle = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: has_negative_cycle = True break return dist, has_negative_cycle 输入与输出 输入为图的邻接矩阵，其中 graph[i][j] 表示从节点 i 到节点 j 的边的权重。如果节点之间没有直接的边，则用一个足够大的值（如 max）表示不可达。\n输出为 path 数组，其中 path[i] 表示从起点到节点 i 的最短路径中，到达节点 i 的前一个节点的索引。如果节点不可达，则 path[i] 为 -1\n若想通过path数组得到从起点到某个节点k的路径，可由如下代码实现：\n1 2 3 4 5 6 7 8 9 10 def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;没有路径可达\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list 代码测试 主程序测试代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 if __name__ == \u0026#34;__main__\u0026#34;: # 图1的顶点数为 5 vertices1 = 5 # 图1的边集合 edges1 = [ Edge(1, 2, 4), Edge(1, 3, 2), Edge(2, 3, 5), Edge(2, 4, 3), Edge(3, 2, -3), Edge(3, 5, 7), Edge(4, 5, 1), Edge(5, 1, 8) ] # 源点为 1 src1 = 1 distances1, has_negative_cycle1 = bellman_ford(vertices1, edges1, src1) print(\u0026#34;图1示例：无负权环图\u0026#34;) if has_negative_cycle1: print(\u0026#34;图中存在负权回路\u0026#34;) else: print(\u0026#34;源点为\u0026#34;, src1, \u0026#34;的最短距离为:\u0026#34;) for i in range(1, vertices1 + 1): print(\u0026#34;到顶点\u0026#34;, i, \u0026#34;的距离为:\u0026#34;, distances1[i]) #-------------------------------------分割线----------------------------------------------- # 图2的顶点数为 3 vertices2 = 3 edges2 = [ Edge(1, 2, 1), Edge(2, 3, 2), Edge(3, 1, -4) # 这条边形成一个负权环 ] src2 = 1 distances2, has_negative_cycle2 = bellman_ford(vertices2, edges2, src2) print(\u0026#34;图2示例：有负权环图\u0026#34;) if has_negative_cycle2: print(\u0026#34;图中存在负权回路\u0026#34;) else: print(\u0026#34;源点为\u0026#34;, src2, \u0026#34;的最短距离为:\u0026#34;) for i in range(1, vertices2 + 1): print(\u0026#34;到顶点\u0026#34;, i, \u0026#34;的距离为:\u0026#34;, distances2[i]) 运行结果为：\n1 2 3 4 5 6 7 8 9 10 11 E:\\BLOG_article\\Bellman-Ford\\.venv\\Scripts\\python.exe E:\\BLOG_article\\Bellman-Ford\\Bellman-Ford.py 图1示例：无负权环图 源点为 1 的最短距离为: 到顶点 1 的距离为: 0 到顶点 2 的距离为: -1 到顶点 3 的距离为: 2 到顶点 4 的距离为: 2 到顶点 5 的距离为: 3 图2示例：有负权环图 图中存在负权回路 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Edge: def __init__(self, src, dest, weight): self.src = src self.dest = dest self.weight = weight def bellman_ford(vertices, edges, src): # 初始化距离数组，距离源点的距离为无穷大 dist = [float(\u0026#39;inf\u0026#39;)] * (vertices + 1) dist[src] = 0 # 源点到自身的距离为 0 # 进行 vertices-1 次松弛操作 for _ in range(vertices - 1): updated = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: dist[v] = dist[u] + weight updated = True if not updated: break # 如果没有边可以松弛，提前退出 # 检测是否存在负权回路 has_negative_cycle = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: has_negative_cycle = True break return dist, has_negative_cycle if __name__ == \u0026#34;__main__\u0026#34;: # 图1的顶点数为 5 vertices1 = 5 # 图1的边集合 edges1 = [ Edge(1, 2, 4), Edge(1, 3, 2), Edge(2, 3, 5), Edge(2, 4, 3), Edge(3, 2, -3), Edge(3, 5, 7), Edge(4, 5, 1), Edge(5, 1, 8) ] # 源点为 1 src1 = 1 distances1, has_negative_cycle1 = bellman_ford(vertices1, edges1, src1) print(\u0026#34;图1示例：无负权环图\u0026#34;) if has_negative_cycle1: print(\u0026#34;图中存在负权回路\u0026#34;) else: print(\u0026#34;源点为\u0026#34;, src1, \u0026#34;的最短距离为:\u0026#34;) for i in range(1, vertices1 + 1): print(\u0026#34;到顶点\u0026#34;, i, \u0026#34;的距离为:\u0026#34;, distances1[i]) #-------------------------------------分割线----------------------------------------------- # 图2的顶点数为 3 vertices2 = 3 edges2 = [ Edge(1, 2, 1), Edge(2, 3, 2), Edge(3, 1, -4) # 这条边形成一个负权环 ] src2 = 1 distances2, has_negative_cycle2 = bellman_ford(vertices2, edges2, src2) print(\u0026#34;图2示例：有负权环图\u0026#34;) if has_negative_cycle2: print(\u0026#34;图中存在负权回路\u0026#34;) else: print(\u0026#34;源点为\u0026#34;, src2, \u0026#34;的最短距离为:\u0026#34;) for i in range(1, vertices2 + 1): print(\u0026#34;到顶点\u0026#34;, i, \u0026#34;的距离为:\u0026#34;, distances2[i]) ","date":"2025-04-26T14:44:25+08:00","image":"https://example.com/p/bellman-ford%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_446bb884ffc0e559.png","permalink":"https://example.com/p/bellman-ford%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"Bellman-Ford算法原理及Python实现"},{"content":"A*算法原理及Python实现 算法简介 A*算法是一种用于求解最短路径问题的启发式搜索算法，广泛应用于机器人路径规划、游戏地图寻路等场景。与 Dijkstra 算法不同，A* 算法结合了实际路径代价和启发式估计，从而能更高效地找到从起点到终点的最优路径。\n算法原理 A*算法基于以下评价函数进行节点选择：\n1 f(n) = g(n) + h(n) g(n)：从起点到当前节点 n 的实际路径代价 h(n)：从当前节点 n 到目标节点的启发式估计（通常使用曼哈顿距离） f(n)：总代价函数，表示当前路径的优劣程度 通过优先扩展 f(n) 最小的节点，A*算法在保证最优性的同时提高了搜索效率。\n曼哈顿距离 A*算法中常用的启发函数之一是曼哈顿距离（Manhattan Distance），适用于只能沿网格上下左右移动的情况。\n它的计算方式为：\n1 2 复制编辑 h(n) = |x₁ - x₂| + |y₁ - y₂| 其中 (x₁, y₁) 是当前节点的坐标，(x₂, y₂) 是目标节点的坐标。\n这种距离计算方式类似在城市街区中沿街道走路，不能穿墙或斜着走，故称为“曼哈顿”——得名于纽约曼哈顿的棋盘格街道布局。\n算法流程 步骤1：初始化 初始化三个核心数组：\ng数组：记录从起点到当前节点的最小代价，初始全部为 ∞，起点为 0 h数组：记录当前节点到目标节点的启发式估值 f数组：记录总代价，f = g + h open_list：优先队列（小顶堆），用于选择当前代价最小的节点 closed_list：已访问节点集合，避免重复扩展 parent字典：记录每个节点的前驱节点 步骤2：选择f值最小的节点 从 open_list 中取出 f(n) 最小的节点，作为当前处理节点。\n步骤3：判断是否到达目标节点 若当前节点为目标节点，则说明路径已找到，调用 seek_path 方法回溯路径。\n步骤4：扩展邻居节点 获取四个方向的可通行邻居节点（上下左右） 对每个邻居，计算新的 g、h、f 值 若该路径更优，则更新邻居节点的代价信息并加入 open_list Python实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import heapq import matplotlib.pyplot as plt import numpy as np class AStar: def __init__(self, grid, start, goal): self.grid = grid self.start = start self.goal = goal self.rows = len(grid) self.cols = len(grid[0]) self.open_list = [] self.closed_list = set() self.f = np.full((self.rows, self.cols), np.inf) self.g = np.full((self.rows, self.cols), np.inf) self.h = np.full((self.rows, self.cols), 0) self.parent = {} def seek_heuristic(self, x, y): return abs(self.goal[0] - x) + abs(self.goal[1] - y) def seek_neighborhood(self, x, y): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] neighbors = [] for dx, dy in directions: if 0 \u0026lt;= x + dx \u0026lt; self.rows and 0 \u0026lt;= y + dy \u0026lt; self.cols and self.grid[x + dx][y + dy] == 0: neighbors.append((x + dx, y + dy)) return neighbors def run(self): self.g[self.start[0], self.start[1]] = 0 self.h[self.start[0], self.start[1]] = self.seek_heuristic(*self.start) self.f[self.start[0], self.start[1]] = self.g[self.start[0], self.start[1]] + self.h[self.start[0], self.start[1]] heapq.heappush(self.open_list, (self.f[self.start[0], self.start[1]], self.start)) while self.open_list: _, current_node = heapq.heappop(self.open_list) if current_node == self.goal: return self.seek_path() self.closed_list.add(current_node) for neighbor in self.seek_neighborhood(*current_node): if neighbor in self.closed_list: continue current_g = self.g[current_node[0], current_node[1]] + 1 if neighbor not in self.parent or current_g \u0026lt; self.g[neighbor[0], neighbor[1]]: self.parent[neighbor] = current_node self.g[neighbor[0], neighbor[1]] = current_g self.h[neighbor[0], neighbor[1]] = self.seek_heuristic(*neighbor) self.f[neighbor[0], neighbor[1]] = self.g[neighbor[0], neighbor[1]] + self.h[neighbor[0], neighbor[1]] if neighbor not in [node[1] for node in self.open_list]: heapq.heappush(self.open_list, (self.f[neighbor[0], neighbor[1]], neighbor)) return None def seek_path(self): path = [] current_node = self.goal while current_node != self.start: path.append(current_node) current_node = self.parent[current_node] path.append(self.start) path.reverse() return path 可视化路径 1 2 3 4 5 6 7 8 9 10 def plot_path(grid, path): plt.figure(figsize=(8, 8)) plt.imshow(grid, cmap=\u0026#39;Greys\u0026#39;, origin=\u0026#39;lower\u0026#39;) path_x, path_y = zip(*path) plt.plot(path_y, path_x, color=\u0026#39;r\u0026#39;, linewidth=2, marker=\u0026#39;o\u0026#39;) plt.scatter(path_y[0], path_x[0], color=\u0026#39;g\u0026#39;, s=100, label=\u0026#39;Start\u0026#39;) plt.scatter(path_y[-1], path_x[-1], color=\u0026#39;b\u0026#39;, s=100, label=\u0026#39;Goal\u0026#39;) plt.legend() plt.title(\u0026#34;A* Pathfinding\u0026#34;) plt.show() 代码测试 主程序测试代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if __name__ == \u0026#34;__main__\u0026#34;: grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) astar = AStar(grid, start, goal) path = astar.run() if path: print(\u0026#34;路径为：\u0026#34;, path) plot_path(grid, path) else: print(\u0026#34;未找到路径\u0026#34;) 运行结果为：\n1 路径为： [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (2, 3), (2, 2), (2, 1), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)] 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import heapq import matplotlib.pyplot as plt import numpy as np class AStar: def __init__(self, grid, start, goal): self.grid=grid self.start=start self.goal=goal self.rows=len(grid) self.cols=len(grid[0]) self.open_list=[] self.closed_list=set() self.f=np.full((self.rows,self.cols),np.inf) self.g=np.full((self.rows,self.cols),np.inf) self.h=np.full((self.rows,self.cols),0) self.parent={} def seek_heuristic(self,x,y): return abs(self.goal[0]-x)+abs(self.goal[1]-y) def seek_neighborhood(self,x,y): directions=[(0,1),(0,-1),(1,0),(-1,0)] neighbors=[] for dx,dy in directions: if 0\u0026lt;=x+dx\u0026lt;self.rows and 0\u0026lt;=y+dy\u0026lt;self.cols and self.grid[x+dx][y+dy]==0: neighbors.append((x+dx,y+dy)) return neighbors def run(self): # 初始化起点 self.g[self.start[0], self.start[1]] = 0 self.h[self.start[0], self.start[1]] = self.seek_heuristic(self.start[0], self.start[1]) self.f[self.start[0], self.start[1]] = self.g[self.start[0], self.start[1]]+self.h[self.start[0], self.start[1]] heapq.heappush(self.open_list,(self.f[self.start[0], self.start[1]],self.start)) while self.open_list: _,current_node=heapq.heappop(self.open_list) if current_node==self.goal: return self.seek_path() self.closed_list.add(current_node) for neighbor in self.seek_neighborhood(current_node[0],current_node[1]): if neighbor in self.closed_list: continue current_g=self.g[current_node[0],current_node[1]] + 1 if neighbor not in self.parent or current_g\u0026lt;self.g[neighbor[0],neighbor[1]]: self.parent[neighbor]=current_node self.g[neighbor[0],neighbor[1]] = current_g self.h[neighbor[0],neighbor[1]] = self.seek_heuristic(neighbor[0],neighbor[1]) self.f[neighbor[0],neighbor[1]] = self.g[neighbor[0],neighbor[1]] + self.h[neighbor[0],neighbor[1]] if neighbor not in [node[1] for node in self.open_list]: heapq.heappush(self.open_list,(self.f[neighbor[0],neighbor[1]],neighbor)) return None def seek_path(self): path=[] current_node=self.goal while current_node!=self.start: path.append(current_node) current_node=self.parent[current_node] path.append(self.start) path.reverse() return path def plot_path(grid,path): plt.figure(figsize=(8, 8)) plt.imshow(grid, cmap=\u0026#39;Greys\u0026#39;, origin=\u0026#39;lower\u0026#39;) path_x, path_y = zip(*path) plt.plot(path_y, path_x, color=\u0026#39;r\u0026#39;, linewidth=2, marker=\u0026#39;o\u0026#39;) plt.scatter(path_y[0], path_x[0], color=\u0026#39;g\u0026#39;, s=100, label=\u0026#39;Start\u0026#39;) plt.scatter(path_y[-1], path_x[-1], color=\u0026#39;b\u0026#39;, s=100, label=\u0026#39;Goal\u0026#39;) plt.legend() plt.title(\u0026#34;A* Pathfinding\u0026#34;) plt.show() # 测试 if __name__ == \u0026#34;__main__\u0026#34;: grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) astar = AStar(grid, start, goal) path = astar.run() if path: print(\u0026#34;Path found:\u0026#34;, path) plot_path(grid, path) else: print(\u0026#34;No path found\u0026#34;) ","date":"2025-04-22T14:44:25+08:00","image":"https://example.com/p/a%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_d5168aa05a06ff51.jpg","permalink":"https://example.com/p/a%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"A*算法原理及Python实现"},{"content":"迪杰斯特拉算法原理及Python实现 算法简介 迪杰斯特拉（Dijkstra）算法主要用于求解没有负值的有向图的单源最短路径问题。\n算法原理 算法基于贪心策略，其核心思想是通过逐步扩展已知最短路径的集合来找到从起点到所有其他节点的最短路径。\n算法流程 步骤1：初始化 初始化cost数组，path数组和visited数组\ncost数组 对于cost数组，初始全部设置为最大值，起点节点设置为0\n1 cost数组：cost[i]表示从start_index到i号元素的最小花费 path数组 对于path数组，初始全部设置为-1，表示不可达，起点节点设置为起点节点的位置\n1 path数组：path[i]表示从start_index到i号元素的最短路径中，到达i号元素的前一个元素索引为path[i]（即想要以最小花费到达i号元素，需要通过path[i]号元素） visited数组 对于visited数组，初始全部设置为0，起点节点设置为1\n1 visited数组：visited[i]表示i号元素是否被访问过（visited[i]==1表示已经找到了最优路径） 步骤2：找到下一个“最优节点” “最优节点”指的是从当前节点到其他节点中代价最小的节点，这个“最优节点”也会作为下一次迭代的“当前节点”\n步骤3：更新visited数组 将找到的最优节点设置成“已访问”状态，即将其设置为“当前节点”\n步骤4：更新“最优节点附近节点的数据” 访问所有还未被访问的节点，若从当前节点“到此节点的代价更小，则更新cost数组和path数组\nPython实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def dijkstra(graph,start_index,max): # 初始化cost,path,visited数组 # cost数组：cost[i]表示从start_index到i号元素的最小花费 cost=[max]*len(graph) cost[start_index] = 0 # path数组：path[i]表示从start_index到i号元素的最短路径中，到达i号元素的前一个元素索引为path[i]（即想要以最小花费到达i号元素，需要通过path[i]号元素） path = [-1] * len(graph) path[start_index] = start_index # visited数组：visited[i]表示i号元素是否被访问过（已经找到了最优路径） visited=[0]*len(graph) visited[start_index]=1 for i in range(len(graph)): if(visited[i]==0): cost[i]=graph[start_index][i] # path[i]=-1表示不可达 path[i]=(start_index if(cost[i]\u0026lt;max) else -1) # 主体代码 for i in range(1,len(graph)): cur_index=-1 min_cost=max # 找到下一步代价最小的节点 for j in range(len(graph)): if(visited[j]==0): if(cost[j]\u0026lt;min_cost): min_cost=cost[j] cur_index=j # 如果没有找到可访问的节点，退出循环 if cur_index==-1: break # 标记下一步代价最小的节点为已访问的节点（当前节点） visited[cur_index]=1 # 依据找到的下一步代价最小的节点cur_index更新其附近一圈的节点数据 for k in range(len(graph)): if(visited[k]==0): if(cost[cur_index]+graph[cur_index][k]\u0026lt;cost[k]): cost[k]=cost[cur_index]+graph[cur_index][k] path[k]=cur_index return path 输入与输出 输入为图的邻接矩阵，其中 graph[i][j] 表示从节点 i 到节点 j 的边的权重。如果节点之间没有直接的边，则用一个足够大的值（如 max）表示不可达。\n输出为 path 数组，其中 path[i] 表示从起点到节点 i 的最短路径中，到达节点 i 的前一个节点的索引。如果节点不可达，则 path[i] 为 -1\n若想通过path数组得到从起点到某个节点k的路径，可由如下代码实现：\n1 2 3 4 5 6 7 8 9 10 def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;没有路径可达\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list 代码测试 主程序测试代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if __name__==\u0026#34;__main__\u0026#34;: max=2**31-1 graph=[ [max, max, 10, max, 30, 100], [max, max, 5, max, max, max], [max, max, max, 50, max, max], [max, max, max, max, max, 10], [max, max, max, 20, max, 60], [max, max, max, max, max, max], ] result=dijkstra(graph,0,max) print(\u0026#34;最短路径的前驱节点数组为：\u0026#34;,result) target_index = 5 path_to_target = get_path(result, 0, target_index) print(f\u0026#34;从起点到目标节点 {target_index} 的路径为：\u0026#34;, path_to_target) 运行结果为：\n1 2 3 E:\\BLOG_article\\Dijkstra\\.venv\\Scripts\\python.exe E:\\BLOG_article\\Dijkstra\\Dijkstra.py 最短路径的前驱节点数组为： [0, -1, 0, 4, 0, 3] 从起点到目标节点 5 的路径为： [0, 4, 3, 5] 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def dijkstra(graph,start_index,max): # 初始化cost,path,visited数组 # cost数组：cost[i]表示从start_index到i号元素的最小花费 cost=[max]*len(graph) cost[start_index] = 0 # path数组：path[i]表示从start_index到i号元素的最短路径中，到达i号元素的前一个元素索引为path[i]（即想要以最小花费到达i号元素，需要通过path[i]号元素） path = [-1] * len(graph) path[start_index] = start_index # visited数组：visited[i]表示i号元素是否被访问过（已经找到了最优路径） visited=[0]*len(graph) visited[start_index]=1 for i in range(len(graph)): if(visited[i]==0): cost[i]=graph[start_index][i] # path[i]=-1表示不可达 path[i]=(start_index if(cost[i]\u0026lt;max) else -1) # 主体代码 for i in range(1,len(graph)): cur_index=-1 min_cost=max # 找到下一步代价最小的节点 for j in range(len(graph)): if(visited[j]==0): if(cost[j]\u0026lt;min_cost): min_cost=cost[j] cur_index=j # 如果没有找到可访问的节点，退出循环 if cur_index==-1: break # 标记下一步代价最小的节点为已访问的节点 visited[cur_index]=1 # 依据找到的下一步代价最小的节点cur_index更新其附近一圈的节点数据 for k in range(len(graph)): if(visited[k]==0): if(cost[cur_index]+graph[cur_index][k]\u0026lt;cost[k]): cost[k]=cost[cur_index]+graph[cur_index][k] path[k]=cur_index return path def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;No path exists\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list if __name__==\u0026#34;__main__\u0026#34;: max=2**31-1 graph=[ [max, max, 10, max, 30, 100], [max, max, 5, max, max, max], [max, max, max, 50, max, max], [max, max, max, max, max, 10], [max, max, max, 20, max, 60], [max, max, max, max, max, max], ] result=dijkstra(graph,0,max) print(\u0026#34;最短路径的前驱节点数组为：\u0026#34;,result) target_index = 5 path_to_target = get_path(result, 0, target_index) print(f\u0026#34;从起点到目标节点 {target_index} 的路径为：\u0026#34;, path_to_target) ","date":"2025-04-13T14:44:25+08:00","image":"https://example.com/p/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_edd18e5053fe4098.png","permalink":"https://example.com/p/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"Dijkstra算法原理及Python实现"},{"content":"标题 标题2 ","date":"2025-04-13T14:44:25+08:00","image":"https://example.com/p/first_test/test_hu_22ab779589b0bb50.png","permalink":"https://example.com/p/first_test/","title":"First_test"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"}]