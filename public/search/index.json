[{"content":"åˆ›å»ºä¸€ä¸ªæ·±åº¦å­¦ä¹ è™šæ‹Ÿç¯å¢ƒï¼ˆåŒ…å«d2låŒ…ï¼‰ Step1 åˆ›å»ºä¸€ä¸ªåä¸ºâ€œd2l_envâ€çš„è™šæ‹Ÿç¯å¢ƒå¹¶æ¿€æ´»ï¼ˆæ¨è Python 3.9ï¼Œå…¼å®¹æ€§æœ€ä½³ï¼‰ï¼š\n1 conda create -n d2l_env python=3.9 1 conda activate d2l_env Step2 ä½¿ç”¨pipå®‰è£…pytorchï¼ˆæœ€æ–°ç‰ˆçš„pytorchå·²ç»ä¸æ”¯æŒcondaå®‰è£…ï¼Œæ•…é‡‡ç”¨pipï¼‰ï¼š\n1 pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121 Step3 ä½¿ç”¨condaå®‰è£…å¸¸è§ç›¸å…³ä¾èµ–\n1 conda install matplotlib pandas jupyter ipykernel Step4 ä½¿ç”¨pipå®‰è£…æŒ‡å®šç‰ˆæœ¬çš„d2låŒ…ï¼š\n1 pip install d2l==1.0.2 Step5 å°†è¿™ä¸ªè™šæ‹Ÿç¯å¢ƒåŠ å…¥jupyter notebookå†…æ ¸ï¼š\n1 python -m ipykernel install --user --name d2l_env --display-name \u0026#34;Python (d2l_env)\u0026#34; ","date":"2025-08-05T14:44:25+08:00","image":"https://example.com/p/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%8C%85%E5%90%ABd2l%E5%8C%85/index_hu_8485bb27c6ba89e1.jpg","permalink":"https://example.com/p/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%8C%85%E5%90%ABd2l%E5%8C%85/","title":"åˆ›å»ºä¸€ä¸ªæ·±åº¦å­¦ä¹ è™šæ‹Ÿç¯å¢ƒï¼ˆåŒ…å«d2låŒ…ï¼‰"},{"content":"çº¿æ€§å›å½’è§£æè§£çš„æ¨å¯¼ é—®é¢˜å½¢å¼åŒ– æˆ‘ä»¬è¦åšçš„æ˜¯ï¼š é¦–å…ˆç»™å®šä¸€ç»„æ•°æ® $$ (X,y)\\quadå…¶ä¸­XâˆˆR^{nÃ—d}ï¼ŒyâˆˆR^n $$è¦æ‹Ÿåˆä¸€ä¸ªçº¿æ€§æ¨¡å‹ $$ y=Xw+b $$ æ‰¾åˆ°ä½¿é¢„æµ‹å’ŒçœŸå®å€¼ä¹‹é—´å‡æ–¹è¯¯å·®æœ€å°çš„wå’Œbã€‚\nå…¶æ¬¡ï¼ŒæŠŠæ¯ä¸ªæ ·æœ¬çš„ç‰¹å¾åé¢åŠ ä¸Šä¸€åˆ—å…¨æ˜¯1çš„åˆ—ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠbä½œä¸ºwçš„ä¸€éƒ¨åˆ†å¤„ç†äº†ã€‚\næ‰€ä»¥ï¼Œå¦‚æœåŸå§‹ X æ˜¯ nÃ—d çŸ©é˜µï¼Œæˆ‘ä»¬æ„é€  $$ {X} = [X \\quad \\mathbf{1}] $$å…¶ä¸­ 1æ˜¯ nÃ—1 çš„å…¨1åˆ—å‘é‡ã€‚ æ­¤æ—¶å‚æ•° $$ ~\\tilde{w} ä¸º(d+1) \\times 1å‘é‡ï¼Œæœ€åä¸€ä¸ªå…ƒç´ å°±æ˜¯b $$ å†™å‡ºç›®æ ‡å‡½æ•° çº¿æ€§å›å½’çš„ç›®æ ‡æ˜¯æœ€å°åŒ–æ®‹å·®å¹³æ–¹å’Œï¼ˆMSEï¼‰ï¼š $$ L(\\tilde{w}) = \\| y - \\tilde{X}\\tilde{w} \\|^2 $$ å°†å…¶å†™æˆçŸ©é˜µç›¸ä¹˜çš„å½¢å¼ï¼š $$ L(w)=âˆ¥yâˆ’Xwâˆ¥^2=(yâˆ’Xw) ^âŠ¤(yâˆ’Xw) $$ å±•å¼€ç›®æ ‡å‡½æ•°ä¸ºï¼š $$ L(w)=y^âŠ¤yâˆ’2y^âŠ¤Xw+w^âŠ¤X^âŠ¤Xw $$ å…¶ä¸­ï¼š $$ ğ‘¦^âŠ¤ğ‘¦y^âŠ¤y æ˜¯å¸¸æ•°é¡¹ $$$$ âˆ’2ğ‘¦^âŠ¤ğ‘‹ğ‘¤âˆ’2y^âŠ¤Xw æ˜¯ä¸€æ¬¡é¡¹ $$$$ w^âŠ¤X^âŠ¤Xw æ˜¯äºŒæ¬¡é¡¹ $$ è§£å‡ºè§£æè§£ ç°åœ¨æ¥å¯¹æ¯ä¸€é¡¹åˆ†åˆ«æ±‚å¯¼ï¼š $$ y^\\top yï¼šè·Ÿwæ— å…³ï¼Œå¯¼æ•°æ˜¯0 $$$$ -2y^\\top Xwï¼šå¯¹wæ±‚å¯¼ï¼Œå°±æ˜¯-2X^\\top y $$$$ w^\\top X^\\top Xw ï¼šå¯¹wæ±‚å¯¼ï¼Œå°±æ˜¯ 2X^\\top X w $$ è¿™æ ·ï¼Œæ•´ä¸ªæŸå¤±å‡½æ•°å¯¹wçš„å¯¼æ•°æ˜¯ï¼š $$ \\frac{\\partial L}{\\partial w} = 0 - 2X^\\top y + 2X^\\top X w\\\\= 2X^\\top X w - 2X^\\top y $$ é›¶å…¶ä¸º0ï¼Œå¾— $$ X^âŠ¤Xw=X^âŠ¤y $$ ä¸¤è¾¹å·¦ä¹˜ $$ (ğ‘‹^âŠ¤ğ‘‹)^{âˆ’1} $$ å¾—åˆ° $$ w=(X^âŠ¤X)^{âˆ’1}X^âŠ¤y $$ é™„ çŸ©é˜µç›¸ä¹˜å±•å¼€ï¼š $$ (aâˆ’b)^âŠ¤(aâˆ’b)=a^âŠ¤aâˆ’a^âŠ¤bâˆ’b^âŠ¤a+b^âŠ¤b\\\\å› ä¸ºğ‘^âŠ¤ğ‘å’Œğ‘^âŠ¤ğ‘æ˜¯æ ‡é‡ï¼ˆå®ƒä»¬äº’ä¸ºè½¬ç½®ï¼Œç»“æœç›¸åŒï¼‰ï¼Œæ‰€ä»¥ä¸Šé¢ä¸­é—´ä¸¤é¡¹å¯ä»¥åˆå¹¶ä¸ºï¼š\\\\ğ‘âŠ¤ğ‘âˆ’2ğ‘âŠ¤ğ‘+ğ‘âŠ¤ğ‘ $$ çŸ©é˜µæ±‚å¯¼åŸºç¡€ï¼š $$ \\frac{\\partial}{\\partial w}(w^\\top A w) = 2Aw\\quadï¼ˆå…¶ä¸­ A æ˜¯å¯¹ç§°çŸ©é˜µï¼‰ $$$$ \\frac{\\partial}{\\partial w}(b^\\top w) = b\\quadï¼ˆb æ˜¯å’Œ w ç»´åº¦ç›¸åŒçš„å‘é‡ï¼‰ $$","date":"2025-08-04T14:44:25+08:00","image":"https://example.com/p/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E8%A7%A3%E6%9E%90%E8%A7%A3%E7%9A%84%E6%8E%A8%E5%AF%BC/index_hu_17c525d58159b80.png","permalink":"https://example.com/p/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E8%A7%A3%E6%9E%90%E8%A7%A3%E7%9A%84%E6%8E%A8%E5%AF%BC/","title":"çº¿æ€§å›å½’è§£æè§£çš„æ¨å¯¼"},{"content":"Bellman-Fordç®—æ³•åŸç†åŠPythonå®ç° ç®—æ³•ç®€ä»‹ Bellman-Fordç®—æ³•ä¸»è¦ç”¨äºæ±‚è§£æœ‰å‘å›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œä¸è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•ä¸åŒï¼Œä»–å¯ä»¥å¤„ç†å¸¦æœ‰è´Ÿæƒå€¼çš„å›¾ï¼Œå¹¶ä¸”å¯ä»¥æ£€æµ‹å›¾ä¸­æ˜¯å¦æœ‰è´Ÿæƒç¯ï¼ˆè´Ÿæƒç¯æŒ‡çš„æ˜¯ä»æºç‚¹åˆ°æºç‚¹çš„ä¸€ä¸ªç¯ï¼Œå¹¶ä¸”ç¯ä¸Šæƒé‡å’Œä¸ºè´Ÿæ•°ï¼‰ã€‚\nç®—æ³•åŸç† â€‹\tå®ƒçš„åŸºæœ¬æ€æƒ³æ˜¯æ¾å¼›ï¼ˆRelaxationï¼‰æ“ä½œã€‚æ¾å¼›æ˜¯æŒ‡å¯¹äºæ¯ä¸€æ¡è¾¹ï¼ˆuï¼Œvï¼‰ï¼Œå¦‚æœä»æºç‚¹åˆ°é¡¶ç‚¹ u çš„æœ€çŸ­è·¯å¾„è·ç¦»å·²çŸ¥ï¼Œå¹¶ä¸”ä»æºç‚¹åˆ°é¡¶ç‚¹ v çš„è·ç¦»å¯ä»¥é€šè¿‡ç»è¿‡é¡¶ç‚¹ u çš„è·¯å¾„æ¥æ›´æ–°ä¸ºä¸€ä¸ªæ›´å°çš„å€¼ï¼Œé‚£ä¹ˆå°±æ›´æ–°é¡¶ç‚¹ v çš„å½“å‰æœ€çŸ­è·¯å¾„è·ç¦»ã€‚\nâ€‹\tç®—æ³•é‡å¤è¿›è¡Œæ¾å¼›æ“ä½œï¼Œå¯¹äºå›¾ä¸­çš„æ¯ä¸€æ¡è¾¹éƒ½è¿›è¡Œæ£€æŸ¥ï¼Œå°è¯•æ›´æ–°é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¼°è®¡å€¼ã€‚è¿™ä¸ªè¿‡ç¨‹éœ€è¦è¿›è¡Œ |V| - 1 æ¬¡ï¼ˆ|V| æ˜¯å›¾ä¸­é¡¶ç‚¹çš„æ•°é‡ï¼‰ï¼Œå› ä¸ºåœ¨æœ€åæƒ…å†µä¸‹ï¼Œä¸€ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„å¯èƒ½éœ€è¦ç»è¿‡æ‰€æœ‰å…¶ä»–é¡¶ç‚¹ã€‚\nâ€‹\tå› æ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º Oï¼ˆ|V|ãƒ»|E|ï¼‰ï¼Œå…¶ä¸­ |V| æ˜¯é¡¶ç‚¹æ•°ï¼Œ|E| æ˜¯è¾¹æ•°ã€‚\nç®—æ³•æµç¨‹ æ­¥éª¤1ï¼šåˆå§‹åŒ– å°†æºç‚¹çš„æœ€çŸ­è·¯å¾„è·ç¦»è®¾ä¸º 0ï¼Œå…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„è·ç¦»è®¾ä¸ºæ— ç©·å¤§ã€‚\næ­¥éª¤2ï¼šåå¤è¿›è¡Œæ¾å¼›æ“ä½œ å¯¹äºæ¯ä¸€æ¡è¾¹ï¼ˆuï¼Œvï¼‰ï¼Œåœ¨ |V| - 1 æ¬¡è¿­ä»£ä¸­ï¼Œå¦‚æœå½“å‰é¡¶ç‚¹ u çš„æœ€çŸ­è·¯å¾„è·ç¦»åŠ ä¸Šè¾¹ï¼ˆuï¼Œvï¼‰çš„æƒé‡å°äºé¡¶ç‚¹ v å½“å‰è®°å½•çš„æœ€çŸ­è·¯å¾„è·ç¦»ï¼Œåˆ™æ›´æ–°é¡¶ç‚¹ v çš„æœ€çŸ­è·¯å¾„è·ç¦»ã€‚\næ­¥éª¤3ï¼šæ£€æµ‹æ˜¯å¦å­˜åœ¨è´Ÿæƒå›è·¯ åœ¨å®Œæˆ |V| - 1 æ¬¡æ¾å¼›æ“ä½œåï¼Œå†å¯¹æ‰€æœ‰è¾¹è¿›è¡Œä¸€æ¬¡æ£€æŸ¥ã€‚å¦‚æœè¿˜èƒ½æ¾å¼›ï¼Œè¯´æ˜å›¾ä¸­å­˜åœ¨ä»æºç‚¹å¯è¾¾çš„è´Ÿæƒå›è·¯ï¼Œæ­¤æ—¶æœ€çŸ­è·¯å¾„ä¸å­˜åœ¨ï¼ˆå› ä¸ºå¯ä»¥æ— é™ç»•è´Ÿæƒå›è·¯æ¥é™ä½è·¯å¾„æƒé‡ï¼‰ã€‚\nPythonå®ç° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Edge: def __init__(self, src, dest, weight): self.src = src self.dest = dest self.weight = weight def bellman_ford(vertices, edges, src): # åˆå§‹åŒ–è·ç¦»æ•°ç»„ï¼Œè·ç¦»æºç‚¹çš„è·ç¦»ä¸ºæ— ç©·å¤§ dist = [float(\u0026#39;inf\u0026#39;)] * (vertices + 1) dist[src] = 0 # æºç‚¹åˆ°è‡ªèº«çš„è·ç¦»ä¸º 0 # è¿›è¡Œ vertices-1 æ¬¡æ¾å¼›æ“ä½œ for _ in range(vertices - 1): updated = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: dist[v] = dist[u] + weight updated = True if not updated: break # å¦‚æœæ²¡æœ‰è¾¹å¯ä»¥æ¾å¼›ï¼Œæå‰é€€å‡º # æ£€æµ‹æ˜¯å¦å­˜åœ¨è´Ÿæƒå›è·¯ has_negative_cycle = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: has_negative_cycle = True break return dist, has_negative_cycle è¾“å…¥ä¸è¾“å‡º è¾“å…¥ä¸ºå›¾çš„é‚»æ¥çŸ©é˜µï¼Œå…¶ä¸­ graph[i][j] è¡¨ç¤ºä»èŠ‚ç‚¹ i åˆ°èŠ‚ç‚¹ j çš„è¾¹çš„æƒé‡ã€‚å¦‚æœèŠ‚ç‚¹ä¹‹é—´æ²¡æœ‰ç›´æ¥çš„è¾¹ï¼Œåˆ™ç”¨ä¸€ä¸ªè¶³å¤Ÿå¤§çš„å€¼ï¼ˆå¦‚ maxï¼‰è¡¨ç¤ºä¸å¯è¾¾ã€‚\nè¾“å‡ºä¸º path æ•°ç»„ï¼Œå…¶ä¸­ path[i] è¡¨ç¤ºä»èµ·ç‚¹åˆ°èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„ä¸­ï¼Œåˆ°è¾¾èŠ‚ç‚¹ i çš„å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ç´¢å¼•ã€‚å¦‚æœèŠ‚ç‚¹ä¸å¯è¾¾ï¼Œåˆ™ path[i] ä¸º -1\nè‹¥æƒ³é€šè¿‡pathæ•°ç»„å¾—åˆ°ä»èµ·ç‚¹åˆ°æŸä¸ªèŠ‚ç‚¹kçš„è·¯å¾„ï¼Œå¯ç”±å¦‚ä¸‹ä»£ç å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;æ²¡æœ‰è·¯å¾„å¯è¾¾\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list ä»£ç æµ‹è¯• ä¸»ç¨‹åºæµ‹è¯•ä»£ç ä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 if __name__ == \u0026#34;__main__\u0026#34;: # å›¾1çš„é¡¶ç‚¹æ•°ä¸º 5 vertices1 = 5 # å›¾1çš„è¾¹é›†åˆ edges1 = [ Edge(1, 2, 4), Edge(1, 3, 2), Edge(2, 3, 5), Edge(2, 4, 3), Edge(3, 2, -3), Edge(3, 5, 7), Edge(4, 5, 1), Edge(5, 1, 8) ] # æºç‚¹ä¸º 1 src1 = 1 distances1, has_negative_cycle1 = bellman_ford(vertices1, edges1, src1) print(\u0026#34;å›¾1ç¤ºä¾‹ï¼šæ— è´Ÿæƒç¯å›¾\u0026#34;) if has_negative_cycle1: print(\u0026#34;å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯\u0026#34;) else: print(\u0026#34;æºç‚¹ä¸º\u0026#34;, src1, \u0026#34;çš„æœ€çŸ­è·ç¦»ä¸º:\u0026#34;) for i in range(1, vertices1 + 1): print(\u0026#34;åˆ°é¡¶ç‚¹\u0026#34;, i, \u0026#34;çš„è·ç¦»ä¸º:\u0026#34;, distances1[i]) #-------------------------------------åˆ†å‰²çº¿----------------------------------------------- # å›¾2çš„é¡¶ç‚¹æ•°ä¸º 3 vertices2 = 3 edges2 = [ Edge(1, 2, 1), Edge(2, 3, 2), Edge(3, 1, -4) # è¿™æ¡è¾¹å½¢æˆä¸€ä¸ªè´Ÿæƒç¯ ] src2 = 1 distances2, has_negative_cycle2 = bellman_ford(vertices2, edges2, src2) print(\u0026#34;å›¾2ç¤ºä¾‹ï¼šæœ‰è´Ÿæƒç¯å›¾\u0026#34;) if has_negative_cycle2: print(\u0026#34;å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯\u0026#34;) else: print(\u0026#34;æºç‚¹ä¸º\u0026#34;, src2, \u0026#34;çš„æœ€çŸ­è·ç¦»ä¸º:\u0026#34;) for i in range(1, vertices2 + 1): print(\u0026#34;åˆ°é¡¶ç‚¹\u0026#34;, i, \u0026#34;çš„è·ç¦»ä¸º:\u0026#34;, distances2[i]) è¿è¡Œç»“æœä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 E:\\BLOG_article\\Bellman-Ford\\.venv\\Scripts\\python.exe E:\\BLOG_article\\Bellman-Ford\\Bellman-Ford.py å›¾1ç¤ºä¾‹ï¼šæ— è´Ÿæƒç¯å›¾ æºç‚¹ä¸º 1 çš„æœ€çŸ­è·ç¦»ä¸º: åˆ°é¡¶ç‚¹ 1 çš„è·ç¦»ä¸º: 0 åˆ°é¡¶ç‚¹ 2 çš„è·ç¦»ä¸º: -1 åˆ°é¡¶ç‚¹ 3 çš„è·ç¦»ä¸º: 2 åˆ°é¡¶ç‚¹ 4 çš„è·ç¦»ä¸º: 2 åˆ°é¡¶ç‚¹ 5 çš„è·ç¦»ä¸º: 3 å›¾2ç¤ºä¾‹ï¼šæœ‰è´Ÿæƒç¯å›¾ å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯ å®Œæ•´ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Edge: def __init__(self, src, dest, weight): self.src = src self.dest = dest self.weight = weight def bellman_ford(vertices, edges, src): # åˆå§‹åŒ–è·ç¦»æ•°ç»„ï¼Œè·ç¦»æºç‚¹çš„è·ç¦»ä¸ºæ— ç©·å¤§ dist = [float(\u0026#39;inf\u0026#39;)] * (vertices + 1) dist[src] = 0 # æºç‚¹åˆ°è‡ªèº«çš„è·ç¦»ä¸º 0 # è¿›è¡Œ vertices-1 æ¬¡æ¾å¼›æ“ä½œ for _ in range(vertices - 1): updated = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: dist[v] = dist[u] + weight updated = True if not updated: break # å¦‚æœæ²¡æœ‰è¾¹å¯ä»¥æ¾å¼›ï¼Œæå‰é€€å‡º # æ£€æµ‹æ˜¯å¦å­˜åœ¨è´Ÿæƒå›è·¯ has_negative_cycle = False for edge in edges: u = edge.src v = edge.dest weight = edge.weight if dist[u] != float(\u0026#39;inf\u0026#39;) and dist[v] \u0026gt; dist[u] + weight: has_negative_cycle = True break return dist, has_negative_cycle if __name__ == \u0026#34;__main__\u0026#34;: # å›¾1çš„é¡¶ç‚¹æ•°ä¸º 5 vertices1 = 5 # å›¾1çš„è¾¹é›†åˆ edges1 = [ Edge(1, 2, 4), Edge(1, 3, 2), Edge(2, 3, 5), Edge(2, 4, 3), Edge(3, 2, -3), Edge(3, 5, 7), Edge(4, 5, 1), Edge(5, 1, 8) ] # æºç‚¹ä¸º 1 src1 = 1 distances1, has_negative_cycle1 = bellman_ford(vertices1, edges1, src1) print(\u0026#34;å›¾1ç¤ºä¾‹ï¼šæ— è´Ÿæƒç¯å›¾\u0026#34;) if has_negative_cycle1: print(\u0026#34;å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯\u0026#34;) else: print(\u0026#34;æºç‚¹ä¸º\u0026#34;, src1, \u0026#34;çš„æœ€çŸ­è·ç¦»ä¸º:\u0026#34;) for i in range(1, vertices1 + 1): print(\u0026#34;åˆ°é¡¶ç‚¹\u0026#34;, i, \u0026#34;çš„è·ç¦»ä¸º:\u0026#34;, distances1[i]) #-------------------------------------åˆ†å‰²çº¿----------------------------------------------- # å›¾2çš„é¡¶ç‚¹æ•°ä¸º 3 vertices2 = 3 edges2 = [ Edge(1, 2, 1), Edge(2, 3, 2), Edge(3, 1, -4) # è¿™æ¡è¾¹å½¢æˆä¸€ä¸ªè´Ÿæƒç¯ ] src2 = 1 distances2, has_negative_cycle2 = bellman_ford(vertices2, edges2, src2) print(\u0026#34;å›¾2ç¤ºä¾‹ï¼šæœ‰è´Ÿæƒç¯å›¾\u0026#34;) if has_negative_cycle2: print(\u0026#34;å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯\u0026#34;) else: print(\u0026#34;æºç‚¹ä¸º\u0026#34;, src2, \u0026#34;çš„æœ€çŸ­è·ç¦»ä¸º:\u0026#34;) for i in range(1, vertices2 + 1): print(\u0026#34;åˆ°é¡¶ç‚¹\u0026#34;, i, \u0026#34;çš„è·ç¦»ä¸º:\u0026#34;, distances2[i]) ","date":"2025-04-26T14:44:25+08:00","image":"https://example.com/p/bellman-ford%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_446bb884ffc0e559.png","permalink":"https://example.com/p/bellman-ford%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"Bellman-Fordç®—æ³•åŸç†åŠPythonå®ç°"},{"content":"A*ç®—æ³•åŸç†åŠPythonå®ç° ç®—æ³•ç®€ä»‹ A*ç®—æ³•æ˜¯ä¸€ç§ç”¨äºæ±‚è§£æœ€çŸ­è·¯å¾„é—®é¢˜çš„å¯å‘å¼æœç´¢ç®—æ³•ï¼Œå¹¿æ³›åº”ç”¨äºæœºå™¨äººè·¯å¾„è§„åˆ’ã€æ¸¸æˆåœ°å›¾å¯»è·¯ç­‰åœºæ™¯ã€‚ä¸ Dijkstra ç®—æ³•ä¸åŒï¼ŒA* ç®—æ³•ç»“åˆäº†å®é™…è·¯å¾„ä»£ä»·å’Œå¯å‘å¼ä¼°è®¡ï¼Œä»è€Œèƒ½æ›´é«˜æ•ˆåœ°æ‰¾åˆ°ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€ä¼˜è·¯å¾„ã€‚\nç®—æ³•åŸç† A*ç®—æ³•åŸºäºä»¥ä¸‹è¯„ä»·å‡½æ•°è¿›è¡ŒèŠ‚ç‚¹é€‰æ‹©ï¼š\n1 f(n) = g(n) + h(n) g(n)ï¼šä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹ n çš„å®é™…è·¯å¾„ä»£ä»· h(n)ï¼šä»å½“å‰èŠ‚ç‚¹ n åˆ°ç›®æ ‡èŠ‚ç‚¹çš„å¯å‘å¼ä¼°è®¡ï¼ˆé€šå¸¸ä½¿ç”¨æ›¼å“ˆé¡¿è·ç¦»ï¼‰ f(n)ï¼šæ€»ä»£ä»·å‡½æ•°ï¼Œè¡¨ç¤ºå½“å‰è·¯å¾„çš„ä¼˜åŠ£ç¨‹åº¦ é€šè¿‡ä¼˜å…ˆæ‰©å±• f(n) æœ€å°çš„èŠ‚ç‚¹ï¼ŒA*ç®—æ³•åœ¨ä¿è¯æœ€ä¼˜æ€§çš„åŒæ—¶æé«˜äº†æœç´¢æ•ˆç‡ã€‚\næ›¼å“ˆé¡¿è·ç¦» A*ç®—æ³•ä¸­å¸¸ç”¨çš„å¯å‘å‡½æ•°ä¹‹ä¸€æ˜¯æ›¼å“ˆé¡¿è·ç¦»ï¼ˆManhattan Distanceï¼‰ï¼Œé€‚ç”¨äºåªèƒ½æ²¿ç½‘æ ¼ä¸Šä¸‹å·¦å³ç§»åŠ¨çš„æƒ…å†µã€‚\nå®ƒçš„è®¡ç®—æ–¹å¼ä¸ºï¼š\n1 2 å¤åˆ¶ç¼–è¾‘ h(n) = |xâ‚ - xâ‚‚| + |yâ‚ - yâ‚‚| å…¶ä¸­ (xâ‚, yâ‚) æ˜¯å½“å‰èŠ‚ç‚¹çš„åæ ‡ï¼Œ(xâ‚‚, yâ‚‚) æ˜¯ç›®æ ‡èŠ‚ç‚¹çš„åæ ‡ã€‚\nè¿™ç§è·ç¦»è®¡ç®—æ–¹å¼ç±»ä¼¼åœ¨åŸå¸‚è¡—åŒºä¸­æ²¿è¡—é“èµ°è·¯ï¼Œä¸èƒ½ç©¿å¢™æˆ–æ–œç€èµ°ï¼Œæ•…ç§°ä¸ºâ€œæ›¼å“ˆé¡¿â€â€”â€”å¾—åäºçº½çº¦æ›¼å“ˆé¡¿çš„æ£‹ç›˜æ ¼è¡—é“å¸ƒå±€ã€‚\nç®—æ³•æµç¨‹ æ­¥éª¤1ï¼šåˆå§‹åŒ– åˆå§‹åŒ–ä¸‰ä¸ªæ ¸å¿ƒæ•°ç»„ï¼š\ngæ•°ç»„ï¼šè®°å½•ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„æœ€å°ä»£ä»·ï¼Œåˆå§‹å…¨éƒ¨ä¸º âˆï¼Œèµ·ç‚¹ä¸º 0 hæ•°ç»„ï¼šè®°å½•å½“å‰èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„å¯å‘å¼ä¼°å€¼ fæ•°ç»„ï¼šè®°å½•æ€»ä»£ä»·ï¼Œf = g + h open_listï¼šä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°é¡¶å †ï¼‰ï¼Œç”¨äºé€‰æ‹©å½“å‰ä»£ä»·æœ€å°çš„èŠ‚ç‚¹ closed_listï¼šå·²è®¿é—®èŠ‚ç‚¹é›†åˆï¼Œé¿å…é‡å¤æ‰©å±• parentå­—å…¸ï¼šè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ æ­¥éª¤2ï¼šé€‰æ‹©få€¼æœ€å°çš„èŠ‚ç‚¹ ä» open_list ä¸­å–å‡º f(n) æœ€å°çš„èŠ‚ç‚¹ï¼Œä½œä¸ºå½“å‰å¤„ç†èŠ‚ç‚¹ã€‚\næ­¥éª¤3ï¼šåˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹ è‹¥å½“å‰èŠ‚ç‚¹ä¸ºç›®æ ‡èŠ‚ç‚¹ï¼Œåˆ™è¯´æ˜è·¯å¾„å·²æ‰¾åˆ°ï¼Œè°ƒç”¨ seek_path æ–¹æ³•å›æº¯è·¯å¾„ã€‚\næ­¥éª¤4ï¼šæ‰©å±•é‚»å±…èŠ‚ç‚¹ è·å–å››ä¸ªæ–¹å‘çš„å¯é€šè¡Œé‚»å±…èŠ‚ç‚¹ï¼ˆä¸Šä¸‹å·¦å³ï¼‰ å¯¹æ¯ä¸ªé‚»å±…ï¼Œè®¡ç®—æ–°çš„ gã€hã€f å€¼ è‹¥è¯¥è·¯å¾„æ›´ä¼˜ï¼Œåˆ™æ›´æ–°é‚»å±…èŠ‚ç‚¹çš„ä»£ä»·ä¿¡æ¯å¹¶åŠ å…¥ open_list Pythonå®ç° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import heapq import matplotlib.pyplot as plt import numpy as np class AStar: def __init__(self, grid, start, goal): self.grid = grid self.start = start self.goal = goal self.rows = len(grid) self.cols = len(grid[0]) self.open_list = [] self.closed_list = set() self.f = np.full((self.rows, self.cols), np.inf) self.g = np.full((self.rows, self.cols), np.inf) self.h = np.full((self.rows, self.cols), 0) self.parent = {} def seek_heuristic(self, x, y): return abs(self.goal[0] - x) + abs(self.goal[1] - y) def seek_neighborhood(self, x, y): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] neighbors = [] for dx, dy in directions: if 0 \u0026lt;= x + dx \u0026lt; self.rows and 0 \u0026lt;= y + dy \u0026lt; self.cols and self.grid[x + dx][y + dy] == 0: neighbors.append((x + dx, y + dy)) return neighbors def run(self): self.g[self.start[0], self.start[1]] = 0 self.h[self.start[0], self.start[1]] = self.seek_heuristic(*self.start) self.f[self.start[0], self.start[1]] = self.g[self.start[0], self.start[1]] + self.h[self.start[0], self.start[1]] heapq.heappush(self.open_list, (self.f[self.start[0], self.start[1]], self.start)) while self.open_list: _, current_node = heapq.heappop(self.open_list) if current_node == self.goal: return self.seek_path() self.closed_list.add(current_node) for neighbor in self.seek_neighborhood(*current_node): if neighbor in self.closed_list: continue current_g = self.g[current_node[0], current_node[1]] + 1 if neighbor not in self.parent or current_g \u0026lt; self.g[neighbor[0], neighbor[1]]: self.parent[neighbor] = current_node self.g[neighbor[0], neighbor[1]] = current_g self.h[neighbor[0], neighbor[1]] = self.seek_heuristic(*neighbor) self.f[neighbor[0], neighbor[1]] = self.g[neighbor[0], neighbor[1]] + self.h[neighbor[0], neighbor[1]] if neighbor not in [node[1] for node in self.open_list]: heapq.heappush(self.open_list, (self.f[neighbor[0], neighbor[1]], neighbor)) return None def seek_path(self): path = [] current_node = self.goal while current_node != self.start: path.append(current_node) current_node = self.parent[current_node] path.append(self.start) path.reverse() return path å¯è§†åŒ–è·¯å¾„ 1 2 3 4 5 6 7 8 9 10 def plot_path(grid, path): plt.figure(figsize=(8, 8)) plt.imshow(grid, cmap=\u0026#39;Greys\u0026#39;, origin=\u0026#39;lower\u0026#39;) path_x, path_y = zip(*path) plt.plot(path_y, path_x, color=\u0026#39;r\u0026#39;, linewidth=2, marker=\u0026#39;o\u0026#39;) plt.scatter(path_y[0], path_x[0], color=\u0026#39;g\u0026#39;, s=100, label=\u0026#39;Start\u0026#39;) plt.scatter(path_y[-1], path_x[-1], color=\u0026#39;b\u0026#39;, s=100, label=\u0026#39;Goal\u0026#39;) plt.legend() plt.title(\u0026#34;A* Pathfinding\u0026#34;) plt.show() ä»£ç æµ‹è¯• ä¸»ç¨‹åºæµ‹è¯•ä»£ç ä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if __name__ == \u0026#34;__main__\u0026#34;: grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) astar = AStar(grid, start, goal) path = astar.run() if path: print(\u0026#34;è·¯å¾„ä¸ºï¼š\u0026#34;, path) plot_path(grid, path) else: print(\u0026#34;æœªæ‰¾åˆ°è·¯å¾„\u0026#34;) è¿è¡Œç»“æœä¸ºï¼š\n1 è·¯å¾„ä¸ºï¼š [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (2, 3), (2, 2), (2, 1), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)] å®Œæ•´ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import heapq import matplotlib.pyplot as plt import numpy as np class AStar: def __init__(self, grid, start, goal): self.grid=grid self.start=start self.goal=goal self.rows=len(grid) self.cols=len(grid[0]) self.open_list=[] self.closed_list=set() self.f=np.full((self.rows,self.cols),np.inf) self.g=np.full((self.rows,self.cols),np.inf) self.h=np.full((self.rows,self.cols),0) self.parent={} def seek_heuristic(self,x,y): return abs(self.goal[0]-x)+abs(self.goal[1]-y) def seek_neighborhood(self,x,y): directions=[(0,1),(0,-1),(1,0),(-1,0)] neighbors=[] for dx,dy in directions: if 0\u0026lt;=x+dx\u0026lt;self.rows and 0\u0026lt;=y+dy\u0026lt;self.cols and self.grid[x+dx][y+dy]==0: neighbors.append((x+dx,y+dy)) return neighbors def run(self): # åˆå§‹åŒ–èµ·ç‚¹ self.g[self.start[0], self.start[1]] = 0 self.h[self.start[0], self.start[1]] = self.seek_heuristic(self.start[0], self.start[1]) self.f[self.start[0], self.start[1]] = self.g[self.start[0], self.start[1]]+self.h[self.start[0], self.start[1]] heapq.heappush(self.open_list,(self.f[self.start[0], self.start[1]],self.start)) while self.open_list: _,current_node=heapq.heappop(self.open_list) if current_node==self.goal: return self.seek_path() self.closed_list.add(current_node) for neighbor in self.seek_neighborhood(current_node[0],current_node[1]): if neighbor in self.closed_list: continue current_g=self.g[current_node[0],current_node[1]] + 1 if neighbor not in self.parent or current_g\u0026lt;self.g[neighbor[0],neighbor[1]]: self.parent[neighbor]=current_node self.g[neighbor[0],neighbor[1]] = current_g self.h[neighbor[0],neighbor[1]] = self.seek_heuristic(neighbor[0],neighbor[1]) self.f[neighbor[0],neighbor[1]] = self.g[neighbor[0],neighbor[1]] + self.h[neighbor[0],neighbor[1]] if neighbor not in [node[1] for node in self.open_list]: heapq.heappush(self.open_list,(self.f[neighbor[0],neighbor[1]],neighbor)) return None def seek_path(self): path=[] current_node=self.goal while current_node!=self.start: path.append(current_node) current_node=self.parent[current_node] path.append(self.start) path.reverse() return path def plot_path(grid,path): plt.figure(figsize=(8, 8)) plt.imshow(grid, cmap=\u0026#39;Greys\u0026#39;, origin=\u0026#39;lower\u0026#39;) path_x, path_y = zip(*path) plt.plot(path_y, path_x, color=\u0026#39;r\u0026#39;, linewidth=2, marker=\u0026#39;o\u0026#39;) plt.scatter(path_y[0], path_x[0], color=\u0026#39;g\u0026#39;, s=100, label=\u0026#39;Start\u0026#39;) plt.scatter(path_y[-1], path_x[-1], color=\u0026#39;b\u0026#39;, s=100, label=\u0026#39;Goal\u0026#39;) plt.legend() plt.title(\u0026#34;A* Pathfinding\u0026#34;) plt.show() # æµ‹è¯• if __name__ == \u0026#34;__main__\u0026#34;: grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) astar = AStar(grid, start, goal) path = astar.run() if path: print(\u0026#34;Path found:\u0026#34;, path) plot_path(grid, path) else: print(\u0026#34;No path found\u0026#34;) ","date":"2025-04-22T14:44:25+08:00","image":"https://example.com/p/a%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_d5168aa05a06ff51.jpg","permalink":"https://example.com/p/a%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"A*ç®—æ³•åŸç†åŠPythonå®ç°"},{"content":"è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•åŸç†åŠPythonå®ç° ç®—æ³•ç®€ä»‹ è¿ªæ°æ–¯ç‰¹æ‹‰ï¼ˆDijkstraï¼‰ç®—æ³•ä¸»è¦ç”¨äºæ±‚è§£æ²¡æœ‰è´Ÿå€¼çš„æœ‰å‘å›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚\nç®—æ³•åŸç† ç®—æ³•åŸºäºè´ªå¿ƒç­–ç•¥ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡é€æ­¥æ‰©å±•å·²çŸ¥æœ€çŸ­è·¯å¾„çš„é›†åˆæ¥æ‰¾åˆ°ä»èµ·ç‚¹åˆ°æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚\nç®—æ³•æµç¨‹ æ­¥éª¤1ï¼šåˆå§‹åŒ– åˆå§‹åŒ–costæ•°ç»„ï¼Œpathæ•°ç»„å’Œvisitedæ•°ç»„\ncostæ•°ç»„ å¯¹äºcostæ•°ç»„ï¼Œåˆå§‹å…¨éƒ¨è®¾ç½®ä¸ºæœ€å¤§å€¼ï¼Œèµ·ç‚¹èŠ‚ç‚¹è®¾ç½®ä¸º0\n1 costæ•°ç»„ï¼šcost[i]è¡¨ç¤ºä»start_indexåˆ°iå·å…ƒç´ çš„æœ€å°èŠ±è´¹ pathæ•°ç»„ å¯¹äºpathæ•°ç»„ï¼Œåˆå§‹å…¨éƒ¨è®¾ç½®ä¸º-1ï¼Œè¡¨ç¤ºä¸å¯è¾¾ï¼Œèµ·ç‚¹èŠ‚ç‚¹è®¾ç½®ä¸ºèµ·ç‚¹èŠ‚ç‚¹çš„ä½ç½®\n1 pathæ•°ç»„ï¼špath[i]è¡¨ç¤ºä»start_indexåˆ°iå·å…ƒç´ çš„æœ€çŸ­è·¯å¾„ä¸­ï¼Œåˆ°è¾¾iå·å…ƒç´ çš„å‰ä¸€ä¸ªå…ƒç´ ç´¢å¼•ä¸ºpath[i]ï¼ˆå³æƒ³è¦ä»¥æœ€å°èŠ±è´¹åˆ°è¾¾iå·å…ƒç´ ï¼Œéœ€è¦é€šè¿‡path[i]å·å…ƒç´ ï¼‰ visitedæ•°ç»„ å¯¹äºvisitedæ•°ç»„ï¼Œåˆå§‹å…¨éƒ¨è®¾ç½®ä¸º0ï¼Œèµ·ç‚¹èŠ‚ç‚¹è®¾ç½®ä¸º1\n1 visitedæ•°ç»„ï¼švisited[i]è¡¨ç¤ºiå·å…ƒç´ æ˜¯å¦è¢«è®¿é—®è¿‡ï¼ˆvisited[i]==1è¡¨ç¤ºå·²ç»æ‰¾åˆ°äº†æœ€ä¼˜è·¯å¾„ï¼‰ æ­¥éª¤2ï¼šæ‰¾åˆ°ä¸‹ä¸€ä¸ªâ€œæœ€ä¼˜èŠ‚ç‚¹â€ â€œæœ€ä¼˜èŠ‚ç‚¹â€æŒ‡çš„æ˜¯ä»å½“å‰èŠ‚ç‚¹åˆ°å…¶ä»–èŠ‚ç‚¹ä¸­ä»£ä»·æœ€å°çš„èŠ‚ç‚¹ï¼Œè¿™ä¸ªâ€œæœ€ä¼˜èŠ‚ç‚¹â€ä¹Ÿä¼šä½œä¸ºä¸‹ä¸€æ¬¡è¿­ä»£çš„â€œå½“å‰èŠ‚ç‚¹â€\næ­¥éª¤3ï¼šæ›´æ–°visitedæ•°ç»„ å°†æ‰¾åˆ°çš„æœ€ä¼˜èŠ‚ç‚¹è®¾ç½®æˆâ€œå·²è®¿é—®â€çŠ¶æ€ï¼Œå³å°†å…¶è®¾ç½®ä¸ºâ€œå½“å‰èŠ‚ç‚¹â€\næ­¥éª¤4ï¼šæ›´æ–°â€œæœ€ä¼˜èŠ‚ç‚¹é™„è¿‘èŠ‚ç‚¹çš„æ•°æ®â€ è®¿é—®æ‰€æœ‰è¿˜æœªè¢«è®¿é—®çš„èŠ‚ç‚¹ï¼Œè‹¥ä»å½“å‰èŠ‚ç‚¹â€œåˆ°æ­¤èŠ‚ç‚¹çš„ä»£ä»·æ›´å°ï¼Œåˆ™æ›´æ–°costæ•°ç»„å’Œpathæ•°ç»„\nPythonå®ç° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def dijkstra(graph,start_index,max): # åˆå§‹åŒ–cost,path,visitedæ•°ç»„ # costæ•°ç»„ï¼šcost[i]è¡¨ç¤ºä»start_indexåˆ°iå·å…ƒç´ çš„æœ€å°èŠ±è´¹ cost=[max]*len(graph) cost[start_index] = 0 # pathæ•°ç»„ï¼špath[i]è¡¨ç¤ºä»start_indexåˆ°iå·å…ƒç´ çš„æœ€çŸ­è·¯å¾„ä¸­ï¼Œåˆ°è¾¾iå·å…ƒç´ çš„å‰ä¸€ä¸ªå…ƒç´ ç´¢å¼•ä¸ºpath[i]ï¼ˆå³æƒ³è¦ä»¥æœ€å°èŠ±è´¹åˆ°è¾¾iå·å…ƒç´ ï¼Œéœ€è¦é€šè¿‡path[i]å·å…ƒç´ ï¼‰ path = [-1] * len(graph) path[start_index] = start_index # visitedæ•°ç»„ï¼švisited[i]è¡¨ç¤ºiå·å…ƒç´ æ˜¯å¦è¢«è®¿é—®è¿‡ï¼ˆå·²ç»æ‰¾åˆ°äº†æœ€ä¼˜è·¯å¾„ï¼‰ visited=[0]*len(graph) visited[start_index]=1 for i in range(len(graph)): if(visited[i]==0): cost[i]=graph[start_index][i] # path[i]=-1è¡¨ç¤ºä¸å¯è¾¾ path[i]=(start_index if(cost[i]\u0026lt;max) else -1) # ä¸»ä½“ä»£ç  for i in range(1,len(graph)): cur_index=-1 min_cost=max # æ‰¾åˆ°ä¸‹ä¸€æ­¥ä»£ä»·æœ€å°çš„èŠ‚ç‚¹ for j in range(len(graph)): if(visited[j]==0): if(cost[j]\u0026lt;min_cost): min_cost=cost[j] cur_index=j # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯è®¿é—®çš„èŠ‚ç‚¹ï¼Œé€€å‡ºå¾ªç¯ if cur_index==-1: break # æ ‡è®°ä¸‹ä¸€æ­¥ä»£ä»·æœ€å°çš„èŠ‚ç‚¹ä¸ºå·²è®¿é—®çš„èŠ‚ç‚¹ï¼ˆå½“å‰èŠ‚ç‚¹ï¼‰ visited[cur_index]=1 # ä¾æ®æ‰¾åˆ°çš„ä¸‹ä¸€æ­¥ä»£ä»·æœ€å°çš„èŠ‚ç‚¹cur_indexæ›´æ–°å…¶é™„è¿‘ä¸€åœˆçš„èŠ‚ç‚¹æ•°æ® for k in range(len(graph)): if(visited[k]==0): if(cost[cur_index]+graph[cur_index][k]\u0026lt;cost[k]): cost[k]=cost[cur_index]+graph[cur_index][k] path[k]=cur_index return path è¾“å…¥ä¸è¾“å‡º è¾“å…¥ä¸ºå›¾çš„é‚»æ¥çŸ©é˜µï¼Œå…¶ä¸­ graph[i][j] è¡¨ç¤ºä»èŠ‚ç‚¹ i åˆ°èŠ‚ç‚¹ j çš„è¾¹çš„æƒé‡ã€‚å¦‚æœèŠ‚ç‚¹ä¹‹é—´æ²¡æœ‰ç›´æ¥çš„è¾¹ï¼Œåˆ™ç”¨ä¸€ä¸ªè¶³å¤Ÿå¤§çš„å€¼ï¼ˆå¦‚ maxï¼‰è¡¨ç¤ºä¸å¯è¾¾ã€‚\nè¾“å‡ºä¸º path æ•°ç»„ï¼Œå…¶ä¸­ path[i] è¡¨ç¤ºä»èµ·ç‚¹åˆ°èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„ä¸­ï¼Œåˆ°è¾¾èŠ‚ç‚¹ i çš„å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ç´¢å¼•ã€‚å¦‚æœèŠ‚ç‚¹ä¸å¯è¾¾ï¼Œåˆ™ path[i] ä¸º -1\nè‹¥æƒ³é€šè¿‡pathæ•°ç»„å¾—åˆ°ä»èµ·ç‚¹åˆ°æŸä¸ªèŠ‚ç‚¹kçš„è·¯å¾„ï¼Œå¯ç”±å¦‚ä¸‹ä»£ç å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;æ²¡æœ‰è·¯å¾„å¯è¾¾\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list ä»£ç æµ‹è¯• ä¸»ç¨‹åºæµ‹è¯•ä»£ç ä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if __name__==\u0026#34;__main__\u0026#34;: max=2**31-1 graph=[ [max, max, 10, max, 30, 100], [max, max, 5, max, max, max], [max, max, max, 50, max, max], [max, max, max, max, max, 10], [max, max, max, 20, max, 60], [max, max, max, max, max, max], ] result=dijkstra(graph,0,max) print(\u0026#34;æœ€çŸ­è·¯å¾„çš„å‰é©±èŠ‚ç‚¹æ•°ç»„ä¸ºï¼š\u0026#34;,result) target_index = 5 path_to_target = get_path(result, 0, target_index) print(f\u0026#34;ä»èµ·ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹ {target_index} çš„è·¯å¾„ä¸ºï¼š\u0026#34;, path_to_target) è¿è¡Œç»“æœä¸ºï¼š\n1 2 3 E:\\BLOG_article\\Dijkstra\\.venv\\Scripts\\python.exe E:\\BLOG_article\\Dijkstra\\Dijkstra.py æœ€çŸ­è·¯å¾„çš„å‰é©±èŠ‚ç‚¹æ•°ç»„ä¸ºï¼š [0, -1, 0, 4, 0, 3] ä»èµ·ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹ 5 çš„è·¯å¾„ä¸ºï¼š [0, 4, 3, 5] å®Œæ•´ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def dijkstra(graph,start_index,max): # åˆå§‹åŒ–cost,path,visitedæ•°ç»„ # costæ•°ç»„ï¼šcost[i]è¡¨ç¤ºä»start_indexåˆ°iå·å…ƒç´ çš„æœ€å°èŠ±è´¹ cost=[max]*len(graph) cost[start_index] = 0 # pathæ•°ç»„ï¼špath[i]è¡¨ç¤ºä»start_indexåˆ°iå·å…ƒç´ çš„æœ€çŸ­è·¯å¾„ä¸­ï¼Œåˆ°è¾¾iå·å…ƒç´ çš„å‰ä¸€ä¸ªå…ƒç´ ç´¢å¼•ä¸ºpath[i]ï¼ˆå³æƒ³è¦ä»¥æœ€å°èŠ±è´¹åˆ°è¾¾iå·å…ƒç´ ï¼Œéœ€è¦é€šè¿‡path[i]å·å…ƒç´ ï¼‰ path = [-1] * len(graph) path[start_index] = start_index # visitedæ•°ç»„ï¼švisited[i]è¡¨ç¤ºiå·å…ƒç´ æ˜¯å¦è¢«è®¿é—®è¿‡ï¼ˆå·²ç»æ‰¾åˆ°äº†æœ€ä¼˜è·¯å¾„ï¼‰ visited=[0]*len(graph) visited[start_index]=1 for i in range(len(graph)): if(visited[i]==0): cost[i]=graph[start_index][i] # path[i]=-1è¡¨ç¤ºä¸å¯è¾¾ path[i]=(start_index if(cost[i]\u0026lt;max) else -1) # ä¸»ä½“ä»£ç  for i in range(1,len(graph)): cur_index=-1 min_cost=max # æ‰¾åˆ°ä¸‹ä¸€æ­¥ä»£ä»·æœ€å°çš„èŠ‚ç‚¹ for j in range(len(graph)): if(visited[j]==0): if(cost[j]\u0026lt;min_cost): min_cost=cost[j] cur_index=j # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯è®¿é—®çš„èŠ‚ç‚¹ï¼Œé€€å‡ºå¾ªç¯ if cur_index==-1: break # æ ‡è®°ä¸‹ä¸€æ­¥ä»£ä»·æœ€å°çš„èŠ‚ç‚¹ä¸ºå·²è®¿é—®çš„èŠ‚ç‚¹ visited[cur_index]=1 # ä¾æ®æ‰¾åˆ°çš„ä¸‹ä¸€æ­¥ä»£ä»·æœ€å°çš„èŠ‚ç‚¹cur_indexæ›´æ–°å…¶é™„è¿‘ä¸€åœˆçš„èŠ‚ç‚¹æ•°æ® for k in range(len(graph)): if(visited[k]==0): if(cost[cur_index]+graph[cur_index][k]\u0026lt;cost[k]): cost[k]=cost[cur_index]+graph[cur_index][k] path[k]=cur_index return path def get_path(path, start_index, target_index): if path[target_index] == -1: return \u0026#34;No path exists\u0026#34; path_list = [] while target_index != start_index: path_list.append(target_index) target_index = path[target_index] path_list.append(start_index) path_list.reverse() return path_list if __name__==\u0026#34;__main__\u0026#34;: max=2**31-1 graph=[ [max, max, 10, max, 30, 100], [max, max, 5, max, max, max], [max, max, max, 50, max, max], [max, max, max, max, max, 10], [max, max, max, 20, max, 60], [max, max, max, max, max, max], ] result=dijkstra(graph,0,max) print(\u0026#34;æœ€çŸ­è·¯å¾„çš„å‰é©±èŠ‚ç‚¹æ•°ç»„ä¸ºï¼š\u0026#34;,result) target_index = 5 path_to_target = get_path(result, 0, target_index) print(f\u0026#34;ä»èµ·ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹ {target_index} çš„è·¯å¾„ä¸ºï¼š\u0026#34;, path_to_target) ","date":"2025-04-13T14:44:25+08:00","image":"https://example.com/p/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/index_hu_edd18e5053fe4098.png","permalink":"https://example.com/p/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","title":"Dijkstraç®—æ³•åŸç†åŠPythonå®ç°"},{"content":"æ ‡é¢˜ æ ‡é¢˜2 ","date":"2025-04-13T14:44:25+08:00","image":"https://example.com/p/first_test/test_hu_22ab779589b0bb50.png","permalink":"https://example.com/p/first_test/","title":"First_test"},{"content":"æ­£æ–‡æµ‹è¯• è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ï¼Œ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æ—¢ç„¶å¦‚ä½•ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ æˆ‘ä»¬ä¸å¾—ä¸é¢å¯¹ä¸€ä¸ªéå¸¸å°´å°¬çš„äº‹å®ï¼Œé‚£å°±æ˜¯ï¼Œ å¯æ˜¯ï¼Œå³ä½¿æ˜¯è¿™æ ·ï¼Œå­¦ç”Ÿä¼šé€€ä¼šçš„å‡ºç°ä»ç„¶ä»£è¡¨äº†ä¸€å®šçš„æ„ä¹‰ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œå‘ç”Ÿäº†ä¼šå¦‚ä½•ï¼Œä¸å‘ç”Ÿåˆä¼šå¦‚ä½•ã€‚ ç»è¿‡ä¸Šè¿°è®¨è®ºï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ è¿™æ ·çœ‹æ¥ï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å°±æˆ‘ä¸ªäººæ¥è¯´ï¼Œå­¦ç”Ÿä¼šé€€ä¼šå¯¹æˆ‘çš„æ„ä¹‰ï¼Œä¸èƒ½ä¸è¯´éå¸¸é‡å¤§ã€‚ èå£«æ¯”äºšæ›¾ç»æåˆ°è¿‡ï¼Œäººçš„ä¸€ç”Ÿæ˜¯çŸ­çš„ï¼Œä½†å¦‚æœå‘åŠ£åœ°è¿‡è¿™ä¸€ç”Ÿï¼Œå°±å¤ªé•¿äº†ã€‚è¿™ä¼¼ä¹è§£ç­”äº†æˆ‘çš„ç–‘æƒ‘ã€‚ è«æ‰ç‰¹è¯´è¿‡ä¸€å¥å¯Œæœ‰å“²ç†çš„è¯ï¼Œè°å’Œæˆ‘ä¸€æ ·ç”¨åŠŸï¼Œè°å°±ä¼šå’Œæˆ‘ä¸€æ ·æˆåŠŸã€‚è¿™å¯å‘äº†æˆ‘ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ äº†è§£æ¸…æ¥šå­¦ç”Ÿä¼šé€€ä¼šåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ï¼Œæ˜¯è§£å†³ä¸€åˆ‡é—®é¢˜çš„å…³é”®ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ã€‚\nå¥¥æ–¯ç‰¹æ´›å¤«æ–¯åŸºæ›¾ç»è¯´è¿‡ï¼Œå…±åŒçš„äº‹ä¸šï¼Œå…±åŒçš„æ–—äº‰ï¼Œå¯ä»¥ä½¿äººä»¬äº§ç”Ÿå¿å—ä¸€åˆ‡çš„åŠ›é‡ã€‚ã€€å¸¦ç€è¿™å¥è¯ï¼Œæˆ‘ä»¬è¿˜è¦æ›´åŠ æ…é‡çš„å®¡è§†è¿™ä¸ªé—®é¢˜ï¼š ä¸€èˆ¬æ¥è®²ï¼Œæˆ‘ä»¬éƒ½å¿…é¡»åŠ¡å¿…æ…é‡çš„è€ƒè™‘è€ƒè™‘ã€‚ æ—¢ç„¶å¦‚æ­¤ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æˆ‘è®¤ä¸ºï¼Œ æˆ‘è®¤ä¸ºï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ è¦æƒ³æ¸…æ¥šï¼Œå­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ã€‚ æˆ‘è®¤ä¸ºï¼Œ æ—¢ç„¶å¦‚æ­¤ï¼Œ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ é‚£ä¹ˆï¼Œ æˆ‘è®¤ä¸ºï¼Œ å­¦ç”Ÿä¼šé€€ä¼šå› ä½•è€Œå‘ç”Ÿã€‚\nå¼•ç”¨ æ€å¿µæ˜¯æœ€æš–çš„å¿§ä¼¤åƒä¸€åŒç¿…è†€\nè®©æˆ‘åœä¸äº†é£ä¸è¿œåœ¨è¿‡å¾€æ¸¸è¡\nä¸å‘Šè€Œåˆ«çš„ä½  å°±ç®—ä¸ºäº†æˆ‘ç€æƒ³\nè¿™ä¹ˆæ²‰ç—›çš„å‘µæŠ¤ æˆ‘æ€ä¹ˆèƒ½ç¿±ç¿”\næœ€æš–çš„æ†‚å‚· - ç”°é¦¥ç”„\nå›¾ç‰‡ 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) ç›¸å†Œè¯­æ³•æ¥è‡ª Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"}]